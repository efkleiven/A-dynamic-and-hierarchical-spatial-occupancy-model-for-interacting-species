# State 1= Unoccupied(U), State 2= vole(A), State 3 = stoat(B), State 4 = vole & stoat(AB) #
############################################################################################
##############
##  Priors  ##
##############
# detection parameters
pA    ~ dunif(0,1)
pB    ~ dunif(0,1)
# site parameters
gamA  ~ dunif(0,1)
gamB  ~ dunif(0,1)
gamAB ~ dunif(0,1)
gamBA ~ dunif(0,1)
epsA  ~ dunif(0,1)
epsB  ~ dunif(0,1)
epsAB ~ dunif(0,1)
epsBA ~ dunif(0,1)
# block parameters
GamA  ~ dunif(0,1)
GamB  ~ dunif(0,1)
GamAB ~ dunif(0,1)
GamBA ~ dunif(0,1)
EpsA  ~ dunif(0,1)
EpsB  ~ dunif(0,1)
EpsAB ~ dunif(0,1)
EpsBA ~ dunif(0,1)
# initial state parameters
for(b in 1:nblock){
for(i in 1:3){
psi[b,i] ~ dunif(0,0.5) # site
}
# First season probabilities for each state
#site
for(j in 1:nsite){
fsm[j, b, 1] <- 1-psi[b,1]-psi[b,2]-psi[b,3]  #-----------|U
fsm[j, b, 2] <- psi[b,1]                      #-----------|A
fsm[j, b, 3] <- psi[b,2]                      #-----------|B
fsm[j, b, 4] <- psi[b,3]                      #-----------|AB
# first season latent state
# for sites
z[j, b, 1] ~ dcat( fsm[j, b, ( 1:nout )])    # site
} # end site loop
# for block, which is just a function of the states of the sites within each block
x[b,1] <- ifelse(sum(z[,b,1]==1) == nsite, 1,
ifelse(sum(z[,b,1]==2) + sum(z[,b,1]==1) == nsite, 2,
ifelse(sum(z[,b,1]==3) + sum(z[,b,1]==1) == nsite, 3, 4) ) )
} # end block loop
#############################################
# block level transition probability matrix #
#############################################
##########################################
# btpm = block transition probability matrix. All columns sum to 1.
#############################################
# U to ...
btpm[ 1, 1] <- (1-GamA) * (1-GamB)    #--|U
btpm[ 2, 1] <- GamA * (1-GamB)        #--|A
btpm[ 3, 1] <- (1-GamA) * GamB        #--|B
btpm[ 4, 1] <- GamA * GamB            #--|AB
# A to ...
btpm[ 1, 2] <- EpsA * (1-GamBA)       #--|U
btpm[ 2, 2] <- (1-EpsA) * (1-GamBA)   #--|A
btpm[ 3, 2] <- EpsA * GamBA           #--|B
btpm[ 4, 2] <- (1-EpsA) * GamBA       #--|AB
# B to ...
btpm[ 1, 3] <- (1-GamAB) * EpsB       #--|U
btpm[ 2, 3] <- GamAB * EpsB           #--|A
btpm[ 3, 3] <- (1-GamAB) * (1-EpsB)   #--|B
btpm[ 4, 3] <- GamAB * (1-EpsB)       #--|AB
# AB to ..
btpm[ 1, 4] <- EpsAB * EpsBA          #--|U
btpm[ 2, 4] <- (1-EpsAB) * EpsBA      #--|A
btpm[ 3, 4] <- EpsAB * (1-EpsBA)      #--|B
btpm[ 4, 4] <- (1-EpsAB) * (1-EpsBA)  #--|AB
####################################################
## stpm = site transition probability matrix.     ##
## These are dependent on the block level state   ##
## All columns sum to 1.                          ##
####################################################
# blocks state (x) = U
# U to ...
stpm[ 1, 1, 1] <- 1          #--|U
stpm[ 2, 1, 1] <- 0          #--|A
stpm[ 3, 1, 1] <- 0          #--|B
stpm[ 4, 1, 1] <- 0          #--|AB
# A to ...
stpm[ 1, 2, 1] <- 1          #--|U
stpm[ 2, 2, 1] <- 0          #--|A
stpm[ 3, 2, 1] <- 0          #--|B
stpm[ 4, 2, 1] <- 0          #--|AB
# B to ...
stpm[1, 3, 1] <- 1           #--|U
stpm[2, 3, 1] <- 0           #--|A
stpm[3, 3, 1] <- 0           #--|B
stpm[4, 3, 1] <- 0           #--|AB
# AB to ..
stpm[1, 4, 1] <- 1           #--|U
stpm[2, 4, 1] <- 0           #--|A
stpm[3, 4, 1] <- 0           #--|B
stpm[4, 4, 1] <- 0           #--|AB
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# blocks state (x) = A
# U to ...
stpm[1, 1, 2] <- (1-gamA)    #--|U
stpm[2, 1, 2] <- gamA        #--|A
stpm[3, 1, 2] <- 0           #--|B
stpm[4, 1, 2] <- 0           #--|AB
# A to ...
stpm[1, 2, 2] <- epsA        #--|U
stpm[2, 2, 2] <- (1-epsA)    #--|A
stpm[3, 2, 2] <- 0           #--|B
stpm[4, 2, 2] <- 0           #--|AB
# B to ...
stpm[1, 3, 2] <- (1-gamAB)   #--|U
stpm[2, 3, 2] <- gamAB       #--|A
stpm[3, 3, 2] <- 0           #--|B
stpm[4, 3, 2] <- 0           #--|AB
# AB to ..
stpm[1, 4, 2] <- epsAB       #--|U
stpm[2, 4, 2] <- (1-epsAB)   #--|A
stpm[3, 4, 2] <- 0           #--|B
stpm[4, 4, 2] <- 0           #--|AB
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# blocks state (x) = B
# U to ...
stpm[1, 1, 3] <-  (1-gamB)    #--|U
stpm[2, 1, 3] <- 0            #--|A
stpm[3, 1, 3] <-  gamB        #--|B
stpm[4, 1, 3] <- 0            #--|AB
# A to ...
stpm[1, 2, 3] <- (1-gamBA)    #--|U
stpm[2, 2, 3] <- 0            #--|A
stpm[3, 2, 3] <- gamBA        #--|B
stpm[4, 2, 3] <- 0            #--|AB
# B to ...
stpm[1, 3, 3] <-  epsB        #--|U
stpm[2, 3, 3] <- 0            #--|A
stpm[3, 3, 3] <- (1-epsB)     #--|B
stpm[4, 3, 3] <- 0            #--|AB
# AB to ..
stpm[1, 4, 3] <-  epsBA       #--|U
stpm[2, 4, 3] <- 0            #--|A
stpm[3, 4, 3] <-  (1-epsBA)   #--|B
stpm[4, 4, 3] <- 0            #--|AB
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# blocks state (x) = AB
# U to ...
stpm[1, 1, 4] <- (1-gamA) * (1-gamB)    #--|U
stpm[2, 1, 4] <- gamA  * (1-gamB)       #--|A
stpm[3, 1, 4] <- (1-gamA) * gamB        #--|B
stpm[4, 1, 4] <- gamA * gamB            #--|AB
# A to ...
stpm[1, 2, 4] <- epsA * (1-gamBA)       #--|U
stpm[2, 2, 4] <- (1-epsA) * (1-gamBA)   #--|A
stpm[3, 2, 4] <- epsA * gamBA           #--|B
stpm[4, 2, 4] <- (1-epsA) * gamBA       #--|AB
# B to ...
stpm[1, 3, 4] <- (1-gamAB ) * epsB      #--|U
stpm[2, 3, 4] <- gamAB  * epsB          #--|A
stpm[3, 3, 4] <- (1-gamAB ) * (1-epsB)  #--|B
stpm[4, 3, 4] <- gamAB  * (1-epsB)      #--|AB
# AB to ..
stpm[1, 4, 4] <- epsAB * epsBA          #--|U
stpm[2, 4, 4] <- (1-epsAB) * epsBA      #--|A
stpm[3, 4, 4] <- epsAB * (1-epsBA)      #--|B
stpm[4, 4, 4] <- (1-epsAB) * (1-epsBA)  #--|AB
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# latent block state for the rest of the seasons
for(t in 1:(nseason-1)){
for(b in 1:nblock){
x[b, t+1] ~ dcat(btpm[(1:nout), x[b, t]])
# latent site state for the rest of the seasons
for(j in 1:nsite){
z[j, b, t+1] ~ dcat( stpm[( 1:nout ) , z[ j, b, t], x[b,t+1]] + 0.01)  # +0.01 to avoide giving the dcat a prob of 0
for(day in 1:nsurvey) {
y[j, b, t, day] ~ dcat( dpm[ ( 1:nout ) , z[j, b, t]] + 0.01)  # +0.01 to avoide giving the dcat a prob of 0
} #end survey loop
} # end site loop
} # end block loop
} # end time loop
#############################################################
## detection matrix (OS = observed state, TS = true state) ##
#############################################################
# TS = U
dpm[ 1, 1] <- 1                #--|OS = U
dpm[ 2, 1] <- 0                #--|OS = A
dpm[ 3, 1] <- 0                #--|OS = B
dpm[ 4, 1] <- 0                #--|OS = AB
# TS = A
dpm[ 1, 2] <- 1-pA             #--|OS = U
dpm[ 2, 2] <- pA               #--|OS = A
dpm[ 3, 2] <- 0                #--|OS = B
dpm[ 4, 2] <- 0                #--|OS = AB
# TS = B
dpm[ 1, 3] <- 1-pB             #--|OS = U
dpm[ 2, 3] <- 0                #--|OS = A
dpm[ 3, 3] <- pB               #--|OS = B
dpm[ 4, 3] <- 0                #--|OS = AB
# TS = AB
dpm[ 1, 4] <- (1-pA) * (1-pB)  #--|OS = U
dpm[ 2, 4] <- pA * (1-pB)      #--|OS = A
dpm[ 3, 4] <- (1-pA) * pB      #--|OS = B
dpm[ 4, 4] <- pA * pB          #--|OS = AB
}# end
",fill = TRUE)
sink()
getwd()
setwd("../")
getwd()
setwd("./simulation_study/model_output")
dir()
load("mod_4stpm_sim_hig_det_test1.rda")
load("mod_4stpm_sim_hig_det.rda")
dat<-c()
for(i in 1:50){
dat[i] <- mod_4stpm_sim_hig_det[[i]]$mean$EpsAB
}
for(i in 1:50){
GamA1[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamA
GamB1[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamB
GamAB1[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamAB
GamBA1[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamBA
EpsA1[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsA
EpsB1[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsB
EpsAB1[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsAB
EpsBA1[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsBA
}
GamA1 <- c()
GamB1 <- c()
GamAB1 <- c()
GamBA1 <- c()
EpsA1<-c()
EpsB1<-c()
EpsAB1<-c()
EpsBA1<-c()
GamA2 <- c()
GamB2 <- c()
GamAB2 <- c()
GamBA2 <- c()
EpsA2<-c()
EpsB2<-c()
EpsAB2<-c()
EpsBA2<-c()
for(i in 1:50){
GamA1[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamA
GamB1[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamB
GamAB1[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamAB
GamBA1[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamBA
EpsA1[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsA
EpsB1[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsB
EpsAB1[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsAB
EpsBA1[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsBA
}
load("mod_4stpm_sim_hig_det_test1.rda")
GamA2[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamA
GamB2[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamB
GamAB2[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamAB
GamBA2[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamBA
EpsA2[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsA
for(i in 1:50){
GamA2[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamA
GamB2[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamB
GamAB2[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamAB
GamBA2[i] <- mod_4stpm_sim_hig_det[[i]]$mean$GamBA
EpsA2[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsA
EpsB2[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsB
EpsAB2[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsAB
EpsBA2[i]<-mod_4stpm_sim_hig_det[[i]]$mean$EpsBA
}
plot(GamA1)
hist(GamA1)
hist(GamA2)
hist(GamB1)
hist(GamB2)
hist(mod_4stpm_sim_hig_det[[1]]$Rhat)
hist(mod_4stpm_sim_hig_det[[1]]$Rhat$z)
rm(list=ls())
# Call jags(and other packages)
library(jagsUI)
library(ggplot2)
library(latex2exp)
getwd()
#load model outputs
load("mod_4stpm_sim_low_det_2.rda")
load("mod_4stpm_sim_mid_det_2.rda")
load("mod_4stpm_sim_hig_det.rda")
load("mod_4stpm_sim_low_occ_2.rda")
load("mod_4stpm_sim_mid_occ_2.rda")
load("mod_4stpm_sim_hig_occ.rda")
# make a array with estimates from all model runs for all gammas and epsilons
dat<-c()
# make a vector of the colonization and extinction estimates from all 50 simulations
for (i in 1:50){
dat[i]     <- mod_4stpm_sim_low_det[[i]]$mean$GamA
dat[i+50]  <- mod_4stpm_sim_mid_det[[i]]$mean$GamA
dat[i+100] <- mod_4stpm_sim_hig_det[[i]]$mean$GamA
dat[i+150] <- mod_4stpm_sim_low_occ[[i]]$mean$GamA
dat[i+200] <- mod_4stpm_sim_mid_occ[[i]]$mean$GamA
dat[i+250] <- mod_4stpm_sim_hig_occ[[i]]$mean$GamA
dat[i+300] <- mod_4stpm_sim_low_det[[i]]$mean$GamB
dat[i+350] <- mod_4stpm_sim_mid_det[[i]]$mean$GamB
dat[i+400] <- mod_4stpm_sim_hig_det[[i]]$mean$GamB
dat[i+450] <- mod_4stpm_sim_low_occ[[i]]$mean$GamB
dat[i+500] <- mod_4stpm_sim_mid_occ[[i]]$mean$GamB
dat[i+550] <- mod_4stpm_sim_hig_occ[[i]]$mean$GamB
dat[i+600] <- mod_4stpm_sim_low_det[[i]]$mean$GamAB
dat[i+650] <- mod_4stpm_sim_mid_det[[i]]$mean$GamAB
dat[i+700] <- mod_4stpm_sim_hig_det[[i]]$mean$GamAB
dat[i+750] <- mod_4stpm_sim_low_occ[[i]]$mean$GamAB
dat[i+800] <- mod_4stpm_sim_mid_occ[[i]]$mean$GamAB
dat[i+850] <- mod_4stpm_sim_hig_occ[[i]]$mean$GamAB
dat[i+900] <- mod_4stpm_sim_low_det[[i]]$mean$GamBA
dat[i+950] <- mod_4stpm_sim_mid_det[[i]]$mean$GamBA
dat[i+1000] <- mod_4stpm_sim_hig_det[[i]]$mean$GamBA
dat[i+1050] <- mod_4stpm_sim_low_occ[[i]]$mean$GamBA
dat[i+1100] <- mod_4stpm_sim_mid_occ[[i]]$mean$GamBA
dat[i+1150] <- mod_4stpm_sim_hig_occ[[i]]$mean$GamBA
dat[i+1200] <- mod_4stpm_sim_low_det[[i]]$mean$EpsA
dat[i+1250] <- mod_4stpm_sim_mid_det[[i]]$mean$EpsA
dat[i+1300] <- mod_4stpm_sim_hig_det[[i]]$mean$EpsA
dat[i+1350] <- mod_4stpm_sim_low_occ[[i]]$mean$EpsA
dat[i+1400] <- mod_4stpm_sim_mid_occ[[i]]$mean$EpsA
dat[i+1450] <- mod_4stpm_sim_hig_occ[[i]]$mean$EpsA
dat[i+1500] <- mod_4stpm_sim_low_det[[i]]$mean$EpsB
dat[i+1550] <- mod_4stpm_sim_mid_det[[i]]$mean$EpsB
dat[i+1600] <- mod_4stpm_sim_hig_det[[i]]$mean$EpsB
dat[i+1650] <- mod_4stpm_sim_low_occ[[i]]$mean$EpsB
dat[i+1700] <- mod_4stpm_sim_mid_occ[[i]]$mean$EpsB
dat[i+1750] <- mod_4stpm_sim_hig_occ[[i]]$mean$EpsB
dat[i+1800] <- mod_4stpm_sim_low_det[[i]]$mean$EpsAB
dat[i+1850] <- mod_4stpm_sim_mid_det[[i]]$mean$EpsAB
dat[i+1900] <- mod_4stpm_sim_hig_det[[i]]$mean$EpsAB
dat[i+1950] <- mod_4stpm_sim_low_occ[[i]]$mean$EpsAB
dat[i+2000] <- mod_4stpm_sim_mid_occ[[i]]$mean$EpsAB
dat[i+2050] <- mod_4stpm_sim_hig_occ[[i]]$mean$EpsAB
dat[i+2100] <- mod_4stpm_sim_low_det[[i]]$mean$EpsBA
dat[i+2150] <- mod_4stpm_sim_mid_det[[i]]$mean$EpsBA
dat[i+2200] <- mod_4stpm_sim_hig_det[[i]]$mean$EpsBA
dat[i+2250] <- mod_4stpm_sim_low_occ[[i]]$mean$EpsBA
dat[i+2300] <- mod_4stpm_sim_mid_occ[[i]]$mean$EpsBA
dat[i+2350] <- mod_4stpm_sim_hig_occ[[i]]$mean$EpsBA
dat[i+2400] <- mod_4stpm_sim_low_det[[i]]$mean$gamA
dat[i+2450] <- mod_4stpm_sim_mid_det[[i]]$mean$gamA
dat[i+2500] <- mod_4stpm_sim_hig_det[[i]]$mean$gamA
dat[i+2550] <- mod_4stpm_sim_low_occ[[i]]$mean$gamA
dat[i+2600] <- mod_4stpm_sim_mid_occ[[i]]$mean$gamA
dat[i+2650] <- mod_4stpm_sim_hig_occ[[i]]$mean$gamA
dat[i+2700] <- mod_4stpm_sim_low_det[[i]]$mean$gamB
dat[i+2750] <- mod_4stpm_sim_mid_det[[i]]$mean$gamB
dat[i+2800] <- mod_4stpm_sim_hig_det[[i]]$mean$gamB
dat[i+2850] <- mod_4stpm_sim_low_occ[[i]]$mean$gamB
dat[i+2900] <- mod_4stpm_sim_mid_occ[[i]]$mean$gamB
dat[i+2950] <- mod_4stpm_sim_hig_occ[[i]]$mean$gamB
dat[i+3000] <- mod_4stpm_sim_low_det[[i]]$mean$gamAB
dat[i+3050] <- mod_4stpm_sim_mid_det[[i]]$mean$gamAB
dat[i+3100] <- mod_4stpm_sim_hig_det[[i]]$mean$gamAB
dat[i+3150] <- mod_4stpm_sim_low_occ[[i]]$mean$gamAB
dat[i+3200] <- mod_4stpm_sim_mid_occ[[i]]$mean$gamAB
dat[i+3250] <- mod_4stpm_sim_hig_occ[[i]]$mean$gamAB
dat[i+3300] <- mod_4stpm_sim_low_det[[i]]$mean$gamBA
dat[i+3350] <- mod_4stpm_sim_mid_det[[i]]$mean$gamBA
dat[i+3400] <- mod_4stpm_sim_hig_det[[i]]$mean$gamBA
dat[i+3450] <- mod_4stpm_sim_low_occ[[i]]$mean$gamBA
dat[i+3500] <- mod_4stpm_sim_mid_occ[[i]]$mean$gamBA
dat[i+3550] <- mod_4stpm_sim_hig_occ[[i]]$mean$gamBA
dat[i+3600] <- mod_4stpm_sim_low_det[[i]]$mean$epsA
dat[i+3650] <- mod_4stpm_sim_mid_det[[i]]$mean$epsA
dat[i+3700] <- mod_4stpm_sim_hig_det[[i]]$mean$epsA
dat[i+3750] <- mod_4stpm_sim_low_occ[[i]]$mean$epsA
dat[i+3800] <- mod_4stpm_sim_mid_occ[[i]]$mean$epsA
dat[i+3850] <- mod_4stpm_sim_hig_occ[[i]]$mean$epsA
dat[i+3900] <- mod_4stpm_sim_low_det[[i]]$mean$epsB
dat[i+3950] <- mod_4stpm_sim_mid_det[[i]]$mean$epsB
dat[i+4000] <- mod_4stpm_sim_hig_det[[i]]$mean$epsB
dat[i+4050] <- mod_4stpm_sim_low_occ[[i]]$mean$epsB
dat[i+4100] <- mod_4stpm_sim_mid_occ[[i]]$mean$epsB
dat[i+4150] <- mod_4stpm_sim_hig_occ[[i]]$mean$epsB
dat[i+4200] <- mod_4stpm_sim_low_det[[i]]$mean$epsAB
dat[i+4250] <- mod_4stpm_sim_mid_det[[i]]$mean$epsAB
dat[i+4300] <- mod_4stpm_sim_hig_det[[i]]$mean$epsAB
dat[i+4350] <- mod_4stpm_sim_low_occ[[i]]$mean$epsAB
dat[i+4400] <- mod_4stpm_sim_mid_occ[[i]]$mean$epsAB
dat[i+4450] <- mod_4stpm_sim_hig_occ[[i]]$mean$epsAB
dat[i+4500] <- mod_4stpm_sim_low_det[[i]]$mean$epsBA
dat[i+4550] <- mod_4stpm_sim_mid_det[[i]]$mean$epsBA
dat[i+4600] <- mod_4stpm_sim_hig_det[[i]]$mean$epsBA
dat[i+4650] <- mod_4stpm_sim_low_occ[[i]]$mean$epsBA
dat[i+4700] <- mod_4stpm_sim_mid_occ[[i]]$mean$epsBA
dat[i+4750] <- mod_4stpm_sim_hig_occ[[i]]$mean$epsBA
}
dat <- as.data.frame(dat) # make into data.frame to be able to add more columns
# add a column describing the parameter name with greek letters
dat$param <- factor(c(rep("GamA", times=300),rep("GamB", times=300),rep("GamAB", times=300),rep("GamBA", times=300),
rep("EpsA", times=300), rep("EpsB", times=300),rep("EpsAB", times=300),rep("EpsBA", times=300),
rep("gamA", times=300),rep("gamB", times=300),rep("gamAB", times=300),rep("gamBA", times=300),
rep("epsA", times=300), rep("epsB", times=300),rep("epsAB", times=300),rep("epsBA", times=300)),
levels=c("GamA","GamB","GamAB","GamBA",
"EpsA","EpsB","EpsAB","EpsBA",
"gamA","gamB","gamAB","gamBA",
"epsA","epsB","epsAB","epsBA"))
# adding a column to describe what set of true parameter values was used
dat$sim <- as.factor(c(rep("ld", times=50),rep("md", times=50),rep("hd", times=50), rep("lo", times=50),rep("mo", times=50),rep("ho", times=50)))
# make data.frame of true parameter values
true <- c()
true[1:16] <- c(0.5, 0.1, 0.05, 0.4, 0.05, 0.6, 0.5, 0.2, 0.5, 0.3, 0.1, 0.7, 0.3, 0.8, 0.9, 0.1)
true[17:32] <- c(0.5, 0.1, 0.05, 0.4, 0.05, 0.6, 0.5, 0.2, 0.5, 0.3, 0.1, 0.7, 0.3, 0.8, 0.9, 0.1)
true[33:48] <- c(0.5, 0.1, 0.05, 0.4, 0.05, 0.6, 0.5, 0.2, 0.5, 0.3, 0.1, 0.7, 0.3, 0.8, 0.9, 0.1)
true[49:64] <- c(0.1, 0.05,0.05, 0.2, 0.1,  0.6, 0.5, 0.2, 0.3, 0.3, 0.1, 0.6, 0.3, 0.8, 0.9, 0.1)
true[65:80] <- c(0.5, 0.1, 0.05, 0.4, 0.05, 0.6, 0.5, 0.2, 0.5, 0.3, 0.1, 0.7, 0.3, 0.8, 0.9, 0.1)
true[81:96] <- c(0.8, 0.2, 0.2,  0.7, 0.05, 0.8, 0.4, 0.2, 0.8, 0.3, 0.1, 0.7, 0.1, 0.6, 0.6, 0.1)
true <- as.data.frame(true) # turn into df to be able to add columns
# estimate mean of simulation means
avr <- aggregate(dat$dat, by=list(dat$param, dat$sim), mean)
std <- aggregate(dat$dat, by=list(dat$param, dat$sim), sd)
# add a column describing the parameter name with greek letters
true$param <- factor(rep(c("GamA","GamB","GamAB","GamBA",
"EpsA","EpsB","EpsAB","EpsBA",
"gamA","gamB","gamAB","gamBA",
"epsA","epsB","epsAB","epsBA"), times=6),
levels=c("GamA","GamB","GamAB","GamBA",
"EpsA","EpsB","EpsAB","EpsBA",
"gamA","gamB","gamAB","gamBA",
"epsA","epsB","epsAB","epsBA") )
# adding a column to describe what set of true parameter values was used
true$sim <- as.factor(c(rep("ld", times=16), rep("md", times=16), rep("hd", times=16), rep("lo", times=16), rep("mo", times=16), rep("ho", times=16)))
names(true)[1] <- "dat"                       # change col name to match the other data frame(dat)
# change col names for avg to match the others
names(avr) <- c(names(true)[2],names(true)[3],names(true)[1])
positions <-c("ld","md","hd", "lo","mo","ho") # spesify what order to plot the simulations
par_names <- list('gamA' = parse(text = TeX("$\\gamma_{A}$")), 'gamB' = parse(text = TeX("$\\gamma_{B}$")),
'gamAB' = parse(text = TeX("$\\gamma_{A|B}$")), 'gamBA' = parse(text = TeX("$\\gamma_{B|A}$")),
'epsA' = parse(text = TeX("$\\epsilon_{A}$")), 'epsB' = parse(text = TeX("$\\epsilon_{B}$")),
'epsAB' = parse(text = TeX("$\\epsilon_{A|B}$")), 'epsBA' = parse(text = TeX("$\\epsilon_{B|A}$")),
'GamA' = parse(text = TeX("$\\Gamma_{A}$")), 'GamB' = parse(text = TeX("$\\Gamma_{B}$")),
'GamAB' = parse(text = TeX("$\\Gamma_{A|B}$")), 'GamBA' = parse(text = TeX("$\\Gamma_{B|A}$")),
'EpsA' = parse(text = TeX("$E_{A}$")), 'EpsB' = parse(text = TeX("$E_{B}$")),
'EpsAB' = parse(text = TeX("$E_{A|B}$")), 'EpsBA' = parse(text = TeX("$E_{B|A}$")) )
par_labeller <- function(variable,value){
return(par_names[value])
}
positions <-c("ld","md","hd", "lo","mo","ho")
ggplot(data=dat, aes(x=sim, y=dat, fill="grey"))+
geom_violin(fill="grey")+
geom_boxplot(width=0.4, color="black", alpha=0.4, fill="white")+
geom_point(data=avr, color="grey40", shape="-", size=20)+
geom_point(data=true, color="red",  shape="-", size=20, alpha=0.8)+
labs(y="", x="")+
facet_wrap(~param, labeller = par_labeller, ncol=4)+
theme(strip.text = element_text(size=12,face="bold"),
axis.text.x = element_text( size = 12, face="bold"),
axis.text.y = element_text( size = 12, face="bold"),
legend.position = "none")+
scale_y_continuous(breaks = c(0, 0.5, 1))+
scale_x_discrete(limits = positions)
ggplot(data=dat, aes(x=sim, y=dat, fill="grey"))+
geom_violin(fill="grey")+
geom_boxplot(width=0.4, color="black", alpha=0.4, fill="white")+
geom_point(data=avr, color="grey40", shape="-", size=20)+
geom_point(data=true, color="red",  shape="-", size=20, alpha=0.8)+
labs(y="", x="")+
facet_wrap(~param,  ncol=4)+
theme(strip.text = element_text(size=12,face="bold"),
axis.text.x = element_text( size = 12, face="bold"),
axis.text.y = element_text( size = 12, face="bold"),
legend.position = "none")+
scale_y_continuous(breaks = c(0, 0.5, 1))+
scale_x_discrete(limits = positions)
ggplot(data=dat, aes(x=sim, y=dat, fill="grey"))+
geom_violin(fill="grey")+
geom_boxplot(width=0.4, color="black", alpha=0.4, fill="white")+
geom_point(data=avr, color="grey40", shape="-", size=20)+
geom_point(data=true, color="red",  shape="-", size=20, alpha=0.8)+
labs(y="", x="")+
facet_wrap(~param, labeller = par_labeller,  ncol=4)+
theme(strip.text = element_text(size=12,face="bold"),
axis.text.x = element_text( size = 12, face="bold"),
axis.text.y = element_text( size = 12, face="bold"),
legend.position = "none")+
scale_y_continuous(breaks = c(0, 0.5, 1))+
scale_x_discrete(limits = positions)
par_names <- list('GamA' = parse(text = TeX("$\\Gamma_{A}$")), 'GamB' = parse(text = TeX("$\\Gamma_{B}$")),
'GamAB' = parse(text = TeX("$\\Gamma_{A|B}$")), 'GamBA' = parse(text = TeX("$\\Gamma_{B|A}$")),
'EpsA' = parse(text = TeX("$E_{A}$")), 'EpsB' = parse(text = TeX("$E_{B}$")),
'EpsAB' = parse(text = TeX("$E_{A|B}$")), 'EpsBA' = parse(text = TeX("$E_{B|A}$")),
'gamA' = parse(text = TeX("$\\gamma_{A}$")), 'gamB' = parse(text = TeX("$\\gamma_{B}$")),
'gamAB' = parse(text = TeX("$\\gamma_{A|B}$")), 'gamBA' = parse(text = TeX("$\\gamma_{B|A}$")),
'epsA' = parse(text = TeX("$\\epsilon_{A}$")), 'epsB' = parse(text = TeX("$\\epsilon_{B}$")),
'epsAB' = parse(text = TeX("$\\epsilon_{A|B}$")), 'epsBA' = parse(text = TeX("$\\epsilon_{B|A}$"))
)
par_labeller <- function(variable,value){
return(par_names[value])
}
positions <-c("ld","md","hd", "lo","mo","ho")
ggplot(data=dat, aes(x=sim, y=dat, fill="grey"))+
geom_violin(fill="grey")+
geom_boxplot(width=0.4, color="black", alpha=0.4, fill="white")+
geom_point(data=avr, color="grey40", shape="-", size=20)+
geom_point(data=true, color="red",  shape="-", size=20, alpha=0.8)+
labs(y="", x="")+
facet_wrap(~param, labeller = par_labeller,  ncol=4)+
theme(strip.text = element_text(size=12,face="bold"),
axis.text.x = element_text( size = 12, face="bold"),
axis.text.y = element_text( size = 12, face="bold"),
legend.position = "none")+
scale_y_continuous(breaks = c(0, 0.5, 1))+
scale_x_discrete(limits = positions)
# save plot
setwd("../plot")
# save plot
setwd("../plot")
#setwd("~/UiT/GitProjects/A-dynamic-and-hierarchical-spatial-occupancy-model-for-interacting-species/simulation_study/plot")
ggsave( "modelperformance_4stpm_sim_gameps_4.png", width = 24, height = 20,units="cm", dpi = 300)
getwd()
